## 연산자
연산자란, 연산을 수행하는 기호를 말한다. 프로그래밍 언어도 수학과 같이 사칙연산들을 제공을 한다.

### 연산자와 피연산자
- 연산자가 연산을 할려면 반드시 연산을 할려는 대상이 필요하다. 그 대상을 피연산자고 부른다.

> 연산자: 연산을 수행하는 기호 (+,-,*,/등)
피연산자: 연산자의 작업 대상 (변수, 상수, 리터럴, 상수)
ex. x+3이라는 수식에 +는 연산자이고, x와 3은 피연산자이다.

- 기본적으로 연산을 할려면 기본적으로 2개의 피연산자가 필요하지만,
  연산자의 종류에 따라 피연산자가 1개 혹은 3개가 필요할 수 있다.
- 연산자는 피연산자로 연산을 수행하고나면, 반드시 반환값을 리턴한다.

### 식과 대입 연산자
- 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현하는 것을 식이라고 한다.
- 그리고 식을 계산하고 결과 값을 얻은 것을 식의 평가라고 한다.
- 식을 사용하고나서 반드시 끝이 ;를 붙여줘야 하며, 그 결과 값을 저장하여
  다른데 사용할려고 하면 반드시 변수에 저장을 해줘야 한다. 그래야 비로소 의미가 있는 코드가 된다.

### 연산자의 종류

|종류|연산자|설명|
|------|---|---|
|산술 연산자|+ - * / % << >>|사칙 연산 (+, -, * , /)과 나머지 연산(%)|
|비교 연산자|> < >= <= == !=|크고 작음과 같음과 다름을 비교|
|논리 연산자|&& \|\| ! \| & ^ ~ |'그리고(AND)'와 '또는(OR)'으로 조건을 연결|
|대입 연산자|=|우변의 값을 좌변에 저장|
|기타|(type) ?: instanceof|형변환 연산자, 삼항 연산자, instanceof 연산자|

> (type)은 '형변환 연산자'를 의미한다.

#### 피연산자의 개수에 의한 분류
- 피연산자의 개수에 따라 연산자를 분류하는데 피연산자가 1개이면 단항연산자, 2개면 이항연산자, 3개면 삼항연산자라고 부른다.
- 대부분 연산자는 이항연산자가 많고 삼항연산자는 '?:' 오직 1개이다.
- 이렇게 연산자를 기능별 피연산자 개수별로 분류하는 것이 나중에 연산자의 우선순위때문에 학습을 하는것인데, 수학의 연산자 우선순위를 알면 배우기 쉬울것 같다.

### 연산자의 우선순위와 결합 규칙
- 식에 사용된 연산자가 2개 이상인 경우 연산자 우선순위에 의해서 연산순서가 결정된다.
- 수학시간에 배웠듯이 +,-보다는 * 와 /가 연산순위가 높다. 자세한건 아래의 표에서 살펴보면 이해가 가능할 것이다.

|식|설명|
|------|---|
|-x + 3|단항 연산자가 이항연산자보다 우선순위가 높다. <br />여기서 단항연산자는 -이고 +가 이항연산자이다.|
|x + 3 * y|곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높다.|
|x + 3 > y - 2|비교연산자 (>)보다 산술연산자 '+', '-'가 먼저 수행한다.|
|x > 3 && x < 5|논리 연산자 '&&'보다 비교 연산자가 먼저 수행된다.|
|result = x + y * 3|대입 연산자는 연산자 중에서 제일 우선순위가 낮다.|

> 위의 표를 보면 우리가 학창시절 수학시간에 배웠던걸로 생각을 하면
쉽게 생각을 할 수 있을 것이다.

|식|설명|
|------|---|
|x << 2 + 1|쉬프트 연산자 (<<)는 덧셈 연산자보다 우선순위가 낮다.|
|data & 0xFF == 0|비트 연산자 (&)는 비교 연산자 (==)보다 우선순위가 <br /> 낮으므로 비교연산 후에 비트연산이 수행된다.|
|x < -1 \|\| x > 3 && x < 5|논리 연산자 중에 AND를 의미하는 &, &&가 OR를 의미하는 \|, \|\| <br />보다 우선순위가 높다.|

> 위의 표를 보면 수학시간에 배웠던걸로는 이해하기가 쉽지 않다. 하지만 위의 표를 잘 상기시키면 우선순위에 대한 문제는 해결될 것이다. 만약 아직도 헷갈린다면 먼저 계산되어야 하는 부분을 괄호로 처리해서 묶어주면 된다.

> ⚠️ 참고
괄호는 연산자가 아니다. 연산자의 우선순위를 임의로 지정할 때, 사용하는
기호일뿐이다.

#### 연산자의 결합 규칙
하나의 식에 연산자가 여러개 있는 경우 어떤 순서로 처리를 해야할까?
우선순위가 같다고 무작정 처리하는 것이 아니고, 나름의 규칙이 있는데
그것이 연산자의 결합 규칙이다.

- 연산자의 결합 규칙은 연산자마다 다르지만, 대부분 왼쪽에서 오른쪽에서 수행하며 단항 연산자와 대입 연산자만 그 반대로 수행한다.

> 💡 요점 정리
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단한 > 이항 > 삼항. 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산자의 진행방향은 왼쪽에서 오른쪽이다.

![](https://velog.velcdn.com/images/roberts/post/02b502e8-cf0b-4f89-9636-6d030d0f32f4/image.jpeg)

### 산술 변환
- 이항 연산자의 경우 두 피연산자의 타입이 일치해야 연산이 가능해야한데, 타입이 다르면 둘 중 하나의 타입으로 일치시켜줘야 한다.
- 그런데 보통 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데, 그 이유는 작은 타입으로 형변환하면 원래의 값이 손실될 가능성이 있기 때문이다.
- 작은 타입에서 큰 타입으로 형변환하는 경우 자동적으로 형변환 되므로, 형변환 연산자를 생략할 수 있다. 이 처럼 피연산자 타입의 일치를 위해 자동 형변환되는 것을 산술변환 또는 일반 산술변환이라 하며, 이 변환은 이항 연산에만 일어나는것이 아니라 단항 연산에서도 일어난다.

> 규칙
1. 두 피연산자의 타입을 같게 일치 시킨다. (보다 큰 타입으로 일치)
2. 피연산자의 타입이 int보다 작은 타입이면, int로 모두 형변환한다.

> 모든 연산에서 산술 변환이 일어나지만, 쉬프트 연산자, 증감 연산자는 예외다.

> 정리
산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
1. 두 피연산자의 타입을 같게 일치 시킨다. (보다 큰 타입으로 일치)
2. 피연산자의 타입이 int보다 작은 타입이면, int로 모두 형변환한다.