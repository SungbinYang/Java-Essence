> 참고
[자바의 정석](http://www.yes24.com/Product/Search?domain=ALL&query=%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D&pid=123487&cosemkid=go16214999081121496&gclid=Cj0KCQjwmuiTBhDoARIsAPiv6L9xwP5-CSNKhbr9xyqRtRORbKj8Eo29uQrx6hkOyS5ruqrFnfFy_h8aAplzEALw_wcB)
https://const17.github.io/5-swap/

## 변수란?
- 단 하나의 값을 저장할 수 있는 메모리 공간
- 새로운 값을 저장하면 기존의 값은 사라진다.

## 변수의 선언과 초기화

``` java
int age; // age라는 이름의 변수를 선언
```

- 위의 코드를 보면 여기서 'int'는 변수의 타입을 의미하며, 'age'는 변수의 이름을 말한다.
- 변수 타입은 변수에 저장될 값이 어떤 타입인지 지정하는 것을 말한다.
- C언어에는 정수형, 실수형, 문자형이 있다.
- 변수 이름은 변수에 이름을 붙이는것으로 메모리 공간에 이름을 붙여주는 것이다.
- 그래야 값도 저장이 가능하고 저장된 값을 읽어 올 수 있다.
- 그래서 같은 이름의 변수는 여러개가 될 수 없다.

> 즉, 메모리의 빈 공간에 변수타입에 알맞은 크기의 저장공간이 확보되고,
이 저장 공간은 변수이름을 통해 사용이 가능하다.

- 변수를 선언한 이후에 변수를 사용이 가능하나, 그 전에 반드시 변수를 초기화해야 한다.
- 메모리는 여러 프로그램이 공유하는 자원이므로, 전에 다른 프로그램에 의해 저장된
  알수 없는 쓰레기 값이 남아 있을 수 있기 때문에 초기화 작업을 거쳐야 한다.
- 초기화 작업은 아래와 같다.

``` java
int age = 25; // 변수 age를 선언하고 25로 초기화 한다.
```

> 위의 코드에 '='은 수학에서는 동등 연산자이지만, 프로그래밍에서는 대입연산자로 쓰인다.

> 변수의 종류에는 클래스 변수, 인스턴스 변수, 지역변수가 존재하는데
여기서 지역변수는 반드시 초기화를 해줘야 한다.

- 변수는 사용되기 전에 변수의 타입을 확인하고 적절한 값으로 초기화 작업을 하는것이 중요하다.

> 변수의 초기화란, 변수를 사용하기 전에 처음으로 값을 저장하는 것

- 변수에 저장된 값을 사용하려면, 그저 변수의 이름만 적어주면 된다.
- 변수의 값을 저장하는 '대입 연산자 (=)'는 우변의 모든 계산이 끝난 후에 제일 마지막에 수행한다.

### 두 변수의 값 교환하기
- 두 변수의 값을 교환하려면 어떻게 해야할까?
- 일반적으로 x라는 변수의 값을 y에 저장하고 y의 값을 x에 저장하면 될것 같지만
  원하는 결과를 얻지 못할 것이다.
- x라는 변수의 값을 y에 저장하면 b의 저장된 값이 변경되기 때문이다.
- 해결책은 아래의 그림처럼 임시 변수를 두는 것이다.

![](https://velog.velcdn.com/images/roberts/post/383987f6-59af-4599-b9b9-c6207c062b53/image.jpeg)

- 위의 그림처럼 temp라는 임시 변수에 값을 넣어두고 y의 값을 x에 temp의 값을 y에 저장해두면 된다.

> 참고
코딩을 하다보면 연산자를 많이 보게 될것이다.
그 중에 '+' 연산자는 두 값을 더하기도 하지만 문자열과 숫자를 하나로 결합하는 역할도 지닌다.

## 변수의 명명 규칙 (Naming Convention)
- 현업에서 일을 하다보면 변수의 이름을 짓는것에 시간을 꽤 투자한다.
- 일단 변수의 이름을 지을때 함부로 a,b,c.. 의미없는 이름을 쓰는것은 좋지 않은 습관이다.
- 또한 지켜야할 규칙이 있는데 바로 아래와 같다.

> 1. 대소문자가 구분되며 길이에 제한이 없다. (의미를 이해할수 있는 길이 정도)
     - True와 true는 서로 다른 것으로 간주된다.
2. 예약어를 사용하면 안 된다.
   - true는 예약어라 사용할 수 없지만, True는 가능하다.
3. 숫자로 시작해서는 안 된다.
   - top10은 허용하지만, 7up은 허용되지 않는다.
4. 특수문자는 '_'와 '$'만을 허용한다.
   - $harp는 허용되지만, S#harp은 허용되지 않는다.

> 예약어란 키워드 또는 리져브드 워드 (reserved word)라고 하는데,
클래스나 변수, 메서드 이름으로 사용할 수 없다.

![](https://velog.velcdn.com/images/roberts/post/0edf0294-3fec-4a6d-b26a-23694dd0febb/image.png)

> goto와 const는 실제로 사용되지 않으며, JDK1.4부터 assert라는 키워드가 추가되었으며
enum은 JDK1.5부터 새로 추가되었다.

## 자바 코드 규칙 (Java Code Convention)
- 필수적인것이 아니지만 자바 개발자들에게 권장하는 규칙들이 있다.

> 1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
     - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. (java Bean rule)
   - lastIndexOf, StringBuffer
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 '_'로 구분한다.
   - PI, MAX_NUMBER

> 참고
자바에서는 모든 이름에 유니코드에 포함된 문자를 사용할 수 있지만, 적어도 클래스 이름은 ASCII코드
(영문자)로 하는것이 좋다. 왜냐하면, 유니코드를 인식하지 못하는 운영체제도 있기 때문이다.

- 또한, 변수의 선언문에 주석으로 변수의 대한 정보를 간략히 적는것도 좋은 생각이다.

## 값의 분류
- 값의 종류는 크게 '문자와 숫자'로 나눌 수 있으며, 숫자는 다시 '정수와 실수'로 나눌 수 있다.

![](https://velog.velcdn.com/images/roberts/post/a5fc0d62-3403-4372-affb-1dd03e86a930/image.png)

- 자료형이란 겂의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이다.
- 변수의 타입은 저장할 값의 타입에 의해 결정이 된다.

## 기본형과 참조형
- 기본형 변수는 실제 값을 저장하는 반면, 참조형 변수는 어떤 값이 저장되어 있는 주소를
  값으로 갖는다.
- 자바는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은
  모두 기본형 변수이다.

> 참조
- 기본형 (primitive type)
    - 논리형(boolean), 문자형 (char), 정수형 (byte, short, int, long),
      실수형 (float, double) 계산을 위한 실제 값을 저장한다.
- 참조형 (reference type) (객체 생성하는 것을 생각하면 된다.)
    - 객체의 주소(메모리 주소)를 저장한다. 8개의 기본형을 제외한 나머지 타입 (4byte or 8byte).
      ex) String, System...

> 클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다.

- 참조 변수는 null 또는 객체의 주소를 값으로 갖는다.
- 참조변수의 초기화는 아래와 같다.

``` java
Date today = new Date(); // Date 객체를 생성해서, 그 주소를 today에 저장.
```

> 참고
참조형 변수는 null 또는 객체의 주소 (4byte)를 값으로 갖는다.
null은 어떤 객체의 주소도 저장되어 있지 않음을 뜻한다.
JVM이 32bit가 아니라 64bit라면 참조형 변수의 크기는 8byte가 된다.

> 자료형과 타입의 차이가 무엇인가?
굳이 차이는 없지만 엄밀히 이야기를 하면 다음과 같다.
기본형의 종류를 이야기할때는 자료형이라고 부르며, 참조형을 이야기 할때는 타입이라고 부른다.
즉, 타입이 자료형을 포함하는 보다 넓은 의미의 용어이므로 **굳이 구분하지 않아도 된다.**

## 기본형
- 기본형에는 모두 8개의 타입이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.
- 논리형
    * boolean
    * true와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용된다.
    * boolean은 다른 기본형과의 연산이 불가능하다.
- 문자형
    * char
    * 문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다.
    * 여러개의 문자를 저장하고 싶을 때는 String이라는 참조형 타입을 써야한다.
    * 문자를 내부적으로 정수 (유니코드)로 저장하기 때문에 정수형과 별반 다르지 않으며
      정수형 또는 실수형과 연산도 가능하다.
- 정수형
    * byte, short, int, long
    * 정수를 저장하는데 사용되며, 주로 int가 사용.
    * byte는 이진 데이터를 다룰 때 사용되며, short는 C언어와의 호환을 위해 추가
    * short 자료형은 잘 사용하지 않는다.
    * 정수형은 일반적으로 int를 사용한다. 왜냐하면, int는 CPU가 가장 효율적으로 처리할 수 있는
      타입이기 때문이다. 효율적인 메모리를 절약하려면 byte나 short를 선택하자.
- 실수형
    * float, double
    * 실수를 저장하는데 사용되며, 주로 double이 사용된다.

![](https://velog.velcdn.com/images/roberts/post/311b0db3-800f-4c74-97eb-137dbe418618/image.jpeg)

- boolean은 true와 flase 2가지 값만 표현할 수 있으면 되므로, 가장 작은 크기인 1byte.
- char은 자바에서 유니코드 (2byte 문자체계)를 사용하므로 2byte.
- byte는 크기가 1byte라서 byte.
- int (4byte)를 기준으로 짧아서 short (2byte), 길어서 long (8byte)
- float는 실수 값을 부동소수점 방식으로 저장하기 때문에 float.
- double은 float보다 2배의 크기 (8byte)를 갖기 때문에 double.

> 참조
n bit의 개수 : 2^n
n bit 중 부호없는 정수의 범위: 0 ~ 2^n -1
n bit 중 부호있는 정수의 범위: -2^(n-1) ~ 2^(n-1) - 1

![](https://velog.velcdn.com/images/roberts/post/365990f3-66c5-4c29-813f-77dd95e13b75/image.png)

- 위의 표를 달달 외울 필요는 없고 정수형 (byte, short, int, long)의 경우
  -2^(n-1) ~ 2^(n-1) - 1 이라는 정도만 기억하자.
- 실수형은 정수형과 달리 같은 크기라도 훨씬 큰 값을 표형할 수 있으나 오차가 발생할 수 있다는
  단점이 있다.
- 그래서 정말도가 중요한데, 정밀도가 높을수록 발생할 수 있는 오차의 범위가 줄어든다.
- float의 정밀도는 7자리인데, 이것은 10진수로 7자리의 수를 오차없이 저장할 수 있다는 뜻이다.

![](https://velog.velcdn.com/images/roberts/post/5c1830d1-c6e1-41ec-bc1e-ba91883b2098/image.png)

- 실수형에서는 저장 가능한 값의 범위뿐만 아니라 정밀도도 타입 선택의 중요한 기준이 된다.

## 상수 (constant)
- 상수는 변수와 같이 값을 저장할 수 있는 공간이지만 변수와 달리 다른 값으로 변경이 불가능하다.
- 상수는 한번만 값을 저장 가능한 변수
- 선언 방법은 변수와 같으며 단지, final 키워드만 붙여주면 된다.

``` java
final int MAX_SPEED = 10; // 상수 MAX_SPEED를 선언 및 초기화
```

- 상수는 반드시 선언과 동시에 초기화 해야하며, 그 후, 상수의 값을 변경하는것은 허용하지 않는다.
- 상수의 이름은 모두 대문자 (Named Convention)로 하는 것이 관례이며
  여러 단어로 이루어져 있으면 '_'로 구분한다.

> JDK1.6부터 상수를 선언과 동시에 초기화하지 않아도 되며, 사용하기 전에 초기화하면 되지만,
왠만하면 선언과 동시에 초기화 하는 습관이 중요하다.

## 리터럴 (literal)
- 리터럴은 우리가 기존에 알고 있던 '상수'의 다른 이름이다.
- 그 자체로 값을 의미하는것을 말한다.
- 프로그램에서 사용하는 모든 숫자, 값, 논리 값 ex) 10, 3.14, 'A', true
- 상수풀에 저장될때 정수는 int, 실수는 double로 저장

``` java
final int MAX_VALUE = 100; // 상수는 MAX_VALUE이고, 리터럴은 100이다.
```

## 상수가 필요한 이유
- 나도 처음에는 왜 상수가 필요한가 생각이 들었다. 리터럴을 직접 쓰면 되는데
  굳이 상수가 왜 필요할까 많은 생각이 들었다.
- 상수를 쓰는 이유는 복잡한 로직에서 리터럴에 '의미 있는 이름'을 붙여서
  코드의 이해와 수정을 쉽게 만들수 있다.

## 리터럴의 타입과 접미사
- 변수의 타입이 존재하는 것처럼 리터럴에도 타입이 존재한다.

![](https://velog.velcdn.com/images/roberts/post/10de0ed8-2eb8-42dc-b54c-3d7fb66ebce8/image.png)

- 리터럴에 붙이는 접미사는 대소문자 구분이 없다.
- 정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 접미사를 붙여서 타입을 구분한다.
- long 타입의 리터럴 접미사는 'l' 또는 'L'을 붙이고 접미사가 없으면 int타입 리터럴로 간주한다.
- byte와 short 타입 리터럴의 접미사는 따로 존재하지 않으며 int 타입 리터럴을 대신 사용한다.
- 또한 10진수 이외에도 2,8,16진수로 표현된 리터럴을 변수에 저장할 수 있으며
  16진수에는 '0x' 또는 '0X'를 사용하며 8진수에는 0을 붙인다.

> 2진수에는 JDK1.7부터 0b를 붙여서 사용한다.

- JDK1.7부터 정수형 리터럴의 중간에 구분자 '_'를 넣을 수 있게 되어 큰 숫자의 가독성이 쉬워졌다.
- 실수형에서 float 타입은 리터럴 접미사에 'f' 또는 'F'를 붙이고,
  double 타입의 리터럴은 'd' 또는 'D'를 붙이지만, 일반적으로 생략이 가능하다.
- 리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e, 그리고 접미사 f,F,d,DFMF 포함하고 있으면
  실수형 리터럴로 간주한다.

|자료형|실수형 리터럴|다른 형태의 동등한 표현|
|------|---|---|
|double|10.|10.0|
|double|.10|0.10|
|float|10f|10.0f|
|float|3.14e3f|3140.0f|
|double|1e1|10.0|
|double|1e-3|0.001|

- 잘 사용하지는 않지만 기호 p를 통해 2의 제곱을 표현하기도 한다.

## 타입의 불일치
- 리터럴의 타입과 변수의 타입이 일치하는게 매우 일반적이지만,
  타입이 달라도 저장범위가 넓은 타입의 값을 저장하는 것은 허용된다.

``` java
int i = 'A' // 문자 'A'의 유니코드인 65가 변수 i에 저장
long l = 123 // int보다 long타입이 더 범위가 넓다.
double d = 3.14f // float보다 double타입이 더 범위가 넓다.
```

- 그러나, 리터럴의 값이 변수의 타입의 범위를 넘어서면 에러가 발생한다.

> 참고
float은 접미사나 정밀도등 여러가지 신경쓸께 많으니, double을 그냥 사용하자.

## 문자 리터럴과 문자열 리터럴
- 작은따옴표로 문자 하나를 감싼 것을 '문자 리터럴', 두 문자 아싱은 큰 따옴표로 감싸야하며
  '문자열 리터럴이라고 한다.'
- char 타입의 변수는 단 하나의 문자만 저장이 가능하며, 여러 문자 (문자열)를 저장하기 위해서는
  String 타입을 사용해야한다.
- 문자열 리터럴에 "" 빈 문자열을 허용하지만, 문자 리터럴은 반드시 ''안에 하나의 문자가 있어야 한다.
- 원래 String은 클래스이므로, 아래와 같이 객체를 생성하는 new 연산자를 사용해야하지만,
  특별히 new 연산자를 사용안해도 된다.

``` java
String name = new String("JAVA");
String name = "JAVA"
```

- 덧셈 연산자를 사용하여 문자열을 결합할 수 있다.
- 덧셈 연산자는 피연산자가 모두 숫자일때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면
  나머지 한쪽을 먼저 String으로 형변환 후, 두 String을 결합한다.

> 문자열 + any type -> 문자열 + 문자열 -> 문자열
any type + 문자열 -> 문자열 + 문자열 -> 문자열

## 형식화된 출력 - printf()
- 화면에 출력할때 우리는 지금까지 System.out.println()을 써왔지만,
  값을 그대로 출력하기 때문에 값을 특정 포맷으로 출력하고 싶을때는 매우 불현하다.
- 이 점을 해결할 함수가 System.out.printf()함수 이다.
- printf() 함수는 지시자를 통해 어떻게 출력할 것인지를 지정해주는 역할을 한다.
- 출력을 2개를 하고 싶으면, 지시자를 2개를 지정해줘야한다.
- println과 또 다른 차이는 printf는 자동으로 개행을 해주지 않아서 %n이라는 지시자를 넣어줘야한다.

|지시자|설명|
|------|---|
|%b|불리언 (boolean) 형식으로 출력|
|%d|10진 정수의 형식으로 출력|
|%o|8진 정수의 형식으로 출력|
|%x, %X|16진 정수의 형식으로 출력|
|%f|부동 소수점의 형식으로 출력|
|%e, %E|지수 표현식의 형식으로 출력|
|%c|문자로 출력|
|%s|문자열로 출력|

> 참조
Integer.toBinaryString(int i) : 정수를 2진 문자열로 변환
%g: 실수형 값을 간략히 표현할때 사용

## 화면에서 입력받기 - Scanner
- Scanner 클래스를 이용하여 사용자가 직접 입력을 할 수도 있다.
- 방법
    * import java.util.*; // Scanner 클래스를 사용하기 위해 추가
    * Scanner scanner = new Scanner(System.in); // Scanner 클래스의 객체 생성
    * String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
    * int num = Integer.parseInt(input); // 입력받은 내용을 input 타입의 값으로 변환

## 10진법과 2진법
- 우리는 일상생활에서 흔히 10진법을 사용한다. 아마 손가락이 10개여서
  우리 인간은 10진법을 받아들였던것 같다.
- 이처럼, 애니악이라는 컴퓨터에도 10진법을 적용시켜보았지만 전압이
  매우 불안정했다. 그래서 컴퓨터 같은 기계에는 전기가 흐르면 1, 전기가
  흐릐지 않으면 0인 2진법을 도입시키게 되었다.
- 그래서 2진법을 제대로 알지 못하면, 컴퓨터의 동작원리, 데이터 처리방식을
  온전히 이해할 수 없게 된다.
- 변수의 저장원리도 마찬가지다. 지금까지는 10진수가 저장되는 것처럼 설명을
  했지만, 사실은 10진수의 정수가 대입이되면, 10진수의 정수가 2진수로 변환되어 저장이 된다.
- 2진법은 0과 1로만 데이터를 표현하기 때문에, 10진수보다 많은 자릿수가
  필요하다.
- 2진수가 자릿수가 많이 필요하긴 하지만, 10진수를 온전히 표현 못하는건 아니다.
  덧셈이나 뺄쎔같은 연산도 10진수와 동일한 로직이다.

## 비트와 바이트
- 한 자리의 2진수를 비트라고 하며, 1비트는 컴퓨터가 값을 저장할 수 있는
  최소단위이다.
- 8비트를 1바이트라고 하며, 데이터의 기본단위로 사용한다.
- 워드는 CPU가 한번에 처리할 수 있는 데이터의 크기를 말하며,
  워드의 크기는 4바이트이긴 하지만 CPU성능에 따라 달라진다.
  ex). 32비트 CPU에서는 1워드는 4바이트이고 64비트 CPU에서는 1워드는 8바이트이다.

![](https://velog.velcdn.com/images/roberts/post/429b9d78-bfa0-4acf-9abe-82d55d9973e1/image.png)

![](https://velog.velcdn.com/images/roberts/post/a4fa59cd-6a4a-4e93-ba6d-9c632b0a20b4/image.png)

> n비트로 표현할 수 있는 10진수
- 값의 개수 : 2^n
- 값의 범위 : 0 ~ (2^n)-1

## 8진법과 16진법
- 8진수는 2진수 3자리를, 16진수는 2진수 4자리를 각각 한자리로 표현할 수 있기 때문에 자리수가 짧아져서 알아보기 쉽고 서로간의 변환방법 또한 매우 간단하다.

![](https://velog.velcdn.com/images/roberts/post/dfdfb68f-677f-4a54-a40c-c3b6bd0ecfb2/image.png)


### 2진수를 8진수, 16진수로 변환

![](https://velog.velcdn.com/images/roberts/post/3aedce32-9d5f-4e6b-8aa0-620e6af61270/image.png)

## 정수의 진법 변환
- 10진수를 n진수로 변환
    * 10진수를 다른 진수로 변환할려면 해당 진수로 나누고
      나머지 값을 옆에 적는 것을 더 이상 나눌 수 없을 때까지
      반복한 다음 마지막 몫과 나머지를 아래부터 위로 순서대로 적으면 된다.
- n진수를 10진수로 변환
    * 어떤 진법의 수라도 변환하는 방법은 똑같다. 각 자리의 수에 해당
      단위의 값을 곱해서 더하면 된다.

## 실수의 진법 변환
- 10진 소수점수를 2진 소수점수로 변환하는 방법
    * 10진 소수점수를 2진 소수점수로 변환하는 방법은 10진 소수점수에
      2를 계속 곱하는 것이다.

  > ex) 0.625의 십진수를 2진수로 변화할려면?
    1) 10진 소수에 2를 곱한다.
    2) 위의 결과에서 소수부만 가져다가 2를 곱한다.
    3) 1,2의 과정을 소수부가 0이 될때 까지 반복한다.
    4) 위의 결과에서 정수부만을 위에서 아래로 순서대로 적고 '0.'을 앞에 붙인다.

- 2진 소수점수를 10진 소수점수로 변환하는 방법
    * 소수점수를 가져다가 (2^-n)식으로 곱해주면 된다.

## 음수의 2진 표현 - 2의 보수법

![](https://velog.velcdn.com/images/roberts/post/ec9b65ea-8a3e-40c4-9fc2-87eb0afa456d/image.png)

- 우리가 앞에서 살펴봤듯이 n비트의 2진수로 표현할 수 있는 부호없는 정수의 값의 개수는 2^n이다.
- 그러면 양수와 음수를 둘다 표현할려면 어떻게 해야할까?
- 왼쪽의 첫번째 비트 (MSB)가 0이면 양수, 1이면 음수로 첫번째 비트만으로
  값의 부호를 알 수 있다.
- 하지만, 첫번째 비트만 바꿔주면 문제점이 발생한다. 양수의 2진수로 첫번째 비트를 1로만 바꿔준 음수를 더하면 논리상 0이되어야 하지만 그렇지가 않는다.
  또한, 0과 -0이 2개가 생긴다는 단점이 있다. 게다가 2진수가 증가할때 10진수는 감소한다는 단점이 존재한다.
- 하지만 2의 보수법을 이용하면 위의 문제점들이 해결이 가능하다. 다만, 첫번째 비트만 바꿔서 음수가 된다는 장점은 사라진다. 하지만 내 생각이지만, 수 많은 단점을 해결하고 장점을 포기한다는 것은 당연한 해결이라고 생각한다.

### 2의 보수법
- 어떤수의 'n의 보수'는 **더했을 때 n이 되는 수**를 말한다.
- 2의 보수도 마찬가지로 더해서 2가되는 두수의 관계를 말한다.
- 즉, 10진수 2는 2진수로 '10'을 의미하며, 자리올림이 발생하고 0이 되는 수를 2의 보수라고 볼수 있다.
- 그래서, 2의 보수 관계를 지닌 두 2진수를 더하면, (자리올림이 발생하고) 0이된다.
- 그래서 2의 보수를 어떻게 구해야 할까? 정답은 각 자리의 수가 1이면 0으로 0이면 1로 바꾼 수에서 1을 덧셈연산을 한다.
- 그러면 음수를 2진수로 바로 변환은 가능할까? 물론 가능하다.
    * 10진 음의 정수를 절대값을 2진수로 변환하고, 2의 보수를 구하면 된다.

> 음수의 2진 표현을 구하는 방법
1. 음수의 절대값을 2진수로 변환한다.
   : -5의 절대값인 5를 2진수로 변환한다. 10진수 5를 2진수로 변환하면 '0101'이 된다.
2. 위의 결과에서 1를 0으로 0을 1로 바꾼다. (1의 보수 구하기)
   : '0101'이 '1010'이 된다.
3. 위의 결과에서 1을 더한다. (2의 보수 구하기, 1의 보수 + 1)
   : '1010'에 1을 더하면 '1011'이 되고 이것이 -5의 2진표현이다.

## 논리형 - boolean
- 논리형에는 boolean 1가지 밖에 없다.
- boolean형 변수에는 true와 false 2가지가 존재하며, 기본 값은 false다.
- 대답 (yes / no), 스위치 (on / off)등의 논리구현에 주로 사용한다.
- 2가지 값만 표현하면 되서 1비트면 충분하지만, 자바에서 데이터를 다루는 최소단위가 byte이기 때문에, boolean 크기는 1byte다.

``` java
boolean power = true;
boolean checked = False; // 에러. 대소문자가 구분됨. true 또는 false만 가능
```

- 자바에서는 데소문자가 구별되기 때문에 TRUE와 true는 다른 것으로 간주된다.

## 문자형 - char
- 문자형에는 char 1가지 자료형 밖에 없다.
- 단 하나의 문자만 저장이 가능하다.
- 사실 문자가 저장이 되는 것이 아니라, 해당되는 문자의 유니코드가 저장이 된다.

``` java
char ch = 'A'; // 문자 'A' (사실은 유니코드)를 char타입의 변수 ch에 저장.
```

- 문자 대신에 유니코드가 저장이 되는 것은 컴퓨터는 숫자밖에 모르기 때문이다.
- 그래서, 문자의 유니코드를 직접 저장할 수 있다.

``` java
char ch = 'A'; // 문자 'A' (사실은 유니코드)를 char타입의 변수 ch에 저장.
char ch = 65; // 문자의 코드를 직접 변수 ch에 저장.
```

- 혹시, 해당하는 문자의 유니코드를 알고 싶다면, 아래와 같이 정수형으로 형변환 하면 된다.

``` java
int code = (int) ch;
```

### 특수문자 다루기
- 영문자 이외에 tab이나 backspace등의 특수문자를 저장하려면 아래와 같은 표처럼 작성하면 된다.

|특수 문자|문자 리터럴|
|------|---|
|tab|\t|
|backspace|\b|
|form feed|\f|
|new line|\n|
|carriage return|\r|
|역슬래쉬|\\\\|
|작은 따옴표|\'|
|큰 따옴표|\"|
|유니코드 (16진수) 문자|\u유니코드 (ex. char a = '\u'0041)|

### char타입의 표현형식
- 정수형과 다른 것은 부호가 없는 정수로만 표현이 된다는 것이다.
- 그래서, 표현할 수 있는 값의 범위가 다르다.

> 16비트로 표현할 수 있는 정수의 개수: 2^16 (65536개)
short타입의 표현범위: -2^15 ~ (2^15) -1 (-32768 ~ 32767)
char타입의 표현범위: 0 ~ (2^16)-1 (0~65535)

- 아래와 같이 'A'와 65를 저장하면 둘다 똑같은 2진수가 저장된다.
  하지만 출력하면 결과가 다르게 나온다. ch는 'A'가 나올것이고 s는 65가 나올 것이다.
- 왜냐하면 컴퓨터는 변수를 해석할 때 값만 보고 해석하는게 아니라 값의 타입까지 확인하고 출력을 하기 때문이다.
- 만약 값의 타입을 모르면 '1231'이라는 것을 일이삼일로 읽을지, 12시 31분으로 읽을 지 모르게 때문이다.

``` java
char ch = 'A';
short s = 65;
```

### 인코딩과 디코딩 (encoding & decoding)
- 컴퓨터가 숫자밖에 모르기 때문에 문자가 숫자로 변환되는 것은 위에서도 언급을 하였다. 하지만 어떤 기준으로 변환을 할까? 그것은 바로 유니코드 표이다.

![](https://velog.velcdn.com/images/roberts/post/6e35441a-2b2e-4d00-8341-5099822b5136/image.png)

- 위의 표 처럼 문자를 코드로 변환하는 것을 문자 인코딩이라 하며, 코드를 문자로 변환하는 것을 문자 디코딩이라고 한다.
- 가끔 인터넷 검색을 하다보면, 페이지 전체가 알아볼수 없는 이상한 글자로 가득 찬 경험이 있을 것이다. 그때마다 버그인가? 해킹당했나?라고 생각하지 말고 해당 html 문서에서 인코딩에 사용된 코드표와 웹브라우저의 설정이 맞지 않아서이다.

### 아스키(ASCII)
- ASCII란, 정보교환을 위한 미국 표준 코드라는 뜻이며, 128개의 문자집합을 제공하는 7bit 부호이다.
- 처음 32개 문자는 제어문자로, 출력할수 없고 33번째 이후 문자들은 출력이
  가능하며, 기호와 숫자, 영소대문자로 이루어져 있다.
- 특징으로는 숫자 (0~9), 영문자 (A~Z, a~z)가 연속적으로 배치되었다는 것이 특징이며, 프로그래밍에서 유용하기 활용된다.

### 확장 아스키(Extended ASCII)와 한글
- 일반적으로 데이터는 1byte단위로 이루어 지는데, 아스키는 7bit이므로, 1bit가 남는다. 그 남는 1bit를 활용하여 문자를 추가 정의한 것이 확장 아스키이다.
- 확장 아스키중에 추가된 문자는 128개의 문자이다. 이 128개의 문자는 여러국가와 기업에서 서로의 필요에 따라 다르게 정의해서 사용한다.
- 그 중 대표적인 것이, ISO 8859-1이다. 주로 서유럽에서 일반적으로 사용하는 문자들을 포함한다.
- 확장 아스키로도 표현하기 힘든 언어가 한글이다. 그래서 생각해낸 방법이 두개의 문자코드로 한글을 표현하는 방법이다.
- 두개의 문자코드를 조합하여 만들어낸 것이 확장 완성형 (CP 949) 방식이다.
- 현재 윈도우 PC에서는 CP 949방식으로 인코딩되어서 저장되어 있다.

### 코드 페이지 (code page, cp)
- PC를 사용하는 지역이나 국가에 따라 여러 버전의 '확장 아스키'가 필요했다.
- 그래서, 여러 버전의 확장 아스키 모음집을 코드 페이지라고 불렀으며, CP xxx 형식으로 이름을 붙였다.
- 그래서, 한글 윈도우는 'CP-949', 영문 윈도우는 'CP-437'을 사용한다.

### 유니코드
- 인터넷의 발명으로 각 국에서 다른 언어를 사용하는 컴퓨터 간의 자료 교환이 활발해지기 시작하면서 서로 다른 문자 인코딩 사용으로 문서교환이 어려워졌다.
- 이에 어려움을 해소하고자, 전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현하였고, 그것이 바로 유니코드이다.
- 처음에 유니코드는 2byte로 표현하기 시작하였으나, 새로운 언어들의 만들어지면서 21bit로 확장이 되었다.
- 새로 추가된 문자들을 보충문자라 불리며, 이 보충문자를 표현할려면 char 자료형이 아닌, int타입을 사용해야 한다.
- 유니코드는 먼저 유니코드에 포함시키고자 하는 문자들의 집합을 정의하였는데, 이것을 유티코드 문자 셋이라고 한다. 이 문자 셋에 번호를 붙인것이 유니코드 인코딩이다.
- 유티코드 인코딩에는 UTF-8, UTF-16, UTF-32등 여러가지가 있지만, 자바에서 사용하는 유니코드 인코딩은 UTF-16이다.
- 모든 문자의 크기가 동일한 UTF-16이 문자를 다루기 편리하지만, 1byte로도 충분히 표현이 가능한, 영문자나 숫자가 2byte가 되므로, 문서의 크기가 매우 커진다.
- UTF-8은 영문자나 숫자는 1byte, 한글은 3byte로 표현되어 문서의 크기가 작지만 가변적이다.
- UTF-8과 UTF-16 둘다 처음 128문자 아스키는 동일하다.
- 하지만, 인터넷 세상에서 문서의 크기가 작은 장점이 더 커서, 요즘은 UTF-8을 이용한다.

> 참고
코드포인트는 유니코드 문자 셋에 순서대로 붙인 일련번호이다.
이 문자들은 번호 (코드 포인트)로 다루는 것이 편리하다.

![](https://velog.velcdn.com/images/roberts/post/aa172966-c764-4045-b5f3-a80d9974b0b9/image.png)


## 정수형
- 정수형은 byte부터 long까지 1byte부터 시작해서 2배씩 크기가 증가한다.
- 기본 자료형은 int이다.

### 정수형의 표현형식과 범위
- 어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다.

![](https://velog.velcdn.com/images/roberts/post/44551672-0cc5-4745-bd47-eada0ac7ec53/image.png)

- 모든 정수형은 부호있는 정수이므로, 왼쪽의 첫번째 비트를 부호비트로 사용하고, 나머지는 값을 표현하는데 사용한다.

> n비트로 표현할 수 있는 정수의 개수 : 2^n개 (2^(n-1)개 + 2^(n-1)개)
n비트로 표현할 수 있는 부호있는 정수의 범위 : -2^(n-1) ~ 2^(n-1) - 1

### 정수형의 선택기준
- 변수에 저장하려는 정수값의 범위에 따라 4개의 정수형 중에서 하나를 선택하면 되지만, byte나 short보다, int를 사용하도록 하자.
- byte나 short가 int보다 크기가 작아서 메모리를 조금 더 절약 할 수 있지만, 저장할 수 있는 값의 범위가 작은 편이라서 연산 시에 범위를 넘어서 잘못된 결과를 얻을 수 있다.
- 그리고 여담이지만, JVM 피연산자 스택이 피연산자를 4byte단위로 저장하기 때문에 byte나 short같은 4byte 아래의 자료형도 4byte로 변환되어 계산되기 때문에 오리혀 int가 효율적이다.
- 정수형 변수를 선언할 때는 int타입으로 하고, int의 범위를 넘어서는 수를 다룰 때는 long을 사용하면 된다.
- byte나 short는 성능보다 저장공간 절약하는것이 더 중요할 때 사용 권장.

> 참고
long타입의 범위를 벗어나는 값을 다룰 때는 실수형 타입이나 BigInteger 클래스를 사용하면 된다.

### 정수형의 오버플로우
- 4bit 2진수의 최댓값인 '1111'에서 1을 더하면 어떻게 될까? 에러 발생?
- 원래는 10000으로 되는것이 맞지만, 4bit밖에 허용이 안되면 0000으로 초기화가 된다.
- 이처럼, 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우라고 한다.
- 오버플로우가 발생하면, 예상하지 못한 결과 값이 나온다. 그래서, 오버플로우가 발생하지 않게, 충분한 크기의 타입을 선택해서 사용해야 한다.
- 쉽게 생각하면 자동차 주행표시기를 생각하면 쉽다.

> 요약정리
최대값 + 1 = 최소값
최소값 - 1 = 최대값

### 부호있는 정수의 오버플로우
- 부호 없는 정수와 부호 있는 정수는 표현범위 즉, 최댓값과 최솟값이 다르기 때문에 오버플로우가 발생하는 시점이 다르다.
- 부호없는 정수는 2진수로 '0000'이 될 때, 오버플로우가 발생하고,
  부호있는 정수는 부호비트가 0에서 1로 될 때 오버플로우가 발생된다.

## 실수형
- 실수형은 말 그대로 실수를 저장하기 위한 자료형으로 float와 doble이 있다. 저장할 수 있는 범위는 아래와 같다.

![](https://velog.velcdn.com/images/roberts/post/5c1830d1-c6e1-41ec-bc1e-ba91883b2098/image.png)

- 실수형은 소수점도 표현해야 하므로, 얼마나 큰 값을 표현할수 있는가 뿐만 아니라 얼마나 0에 가깝게 표현할 수 있는가도 중요하다.

> Q. 실수형도 정수형처럼 오버플로우가 발생하는가?
A. 정수형과 달리, 실수형에서는 오버플로우가 발생하면 변수의 값은 무한대가 된다. 그리고 정수형에 없던 언더 플로우가 있는데, 언더플로우는 실수형으로도 표현할 수 없는 아주 작은 값, 즉, 양의 최소 값보다 작은 값이 되는 경우를 말한다.

- 같은 byte로 정수형보다 많은 범위를 낼수 있을까? int형과 float형은 똑같은 4byte이지만, float형이 훨씬 많은 범위를 표현할 수 있다.
- 그 이유는 값을 저장하는 형식이 다르기 때문이다. 정수형은 부호와 값 2가지로 이루어져 있지만, 실수형은 부후부, 지수부, 가수부로 나눠진다. 즉, 2의 제곱형태로 값을 저장하기 때문에 똑같은 byte로도 많은 범위를 표현할 수 있는것이다.
- 하지만, 이런 장점만 있으면, 우리 개발자들은 실수형만 썼을 것이다. 정말로 치명적인 단점이 존재한다. 바로, 오차가 발생할 수 있다는 단점이 있다. 그래서 실수형은 값의 범위보다도, 정밀도 또한 아주 중요한 요인으로 들어간다.
- float는 정밀도가 7자리이고, 그 이상은 double을 사용한다. 이것이 우리 개발자들이 실수형을 표현할 때 double형을 작성하는 이유이다.
- 저장하려는 값의 범위보다도, 보다 높은 정밀도가 필요해서이다.
- 그래서 메모리를 절약하는것이 더 중요한 프로그램에서는 float을 쓰고,
  그 외에는 double을 사용한다.

### 실수형의 저장형식
- 실수형은 앞에서 이야기를 했듯이 정수형과 표현형식이 달라서, 실수형은 값을 부동소수점 형태로 저장한다.
- 부동소수점은 부호부, 지수부, 가수부로 이루어진다.

|기호|의미|설명|
|------|---|---|
|S|부호|0이면 양수, 1이면 음수|
|E|지수|부호 있는정수, 지수의 범위는<br /> -127 ~ 128 (float), -1023 ~ 1024 (double)|
|M|가수|실재 값을 저장하는 부분. <br /> 10진수로 7자리 (float), 15자리 (double)의 정말도로 저장 가능|

#### 부호부
- 정수형과 달리 2의 보수법을 사용하지 않기 때문에, 양의 실수를 음의 실수로 바꾸려면, 그저 부호비트만 바꿔주면 된다.

#### 지수부
- 지수부는 지수를 저장하는 부분으로 float의 경우는 8bit의 저장공간을 갖는다. 즉, -127 ~ 128의 범위가 저장된다.
- 하지만 NaN, 양의 무한대, 음의 무한대와 같이 특별한 값의 표현을 위해 예약되어 있으므로 실제로 사용가능한 지수의 범위는 -126 ~ 127이다.


#### 가수부
- 가수부는 실제 값인 가수를 저장하는 부분으로 float의 경우는 2진수 23자리를 저장 가능하다. 즉, 10진수로 7자리를 저장할 수 있는데 이것이 정밀도다. double의 경우는 float의 정밀도의 2배이다.

##### 부동 소수점의 오차
- 실수중에는 파이같은 무한소수가 존재하므로, 정수와 달리 실수를 저장할때는 오차가 발생할 수 있다.
- 게다가 10진수가 아닌 2진수로 저장하기 때문에, 10진수에서 유한소수더라도 2진수로는 무한소수가 될 수 있다. 2진소수로는 10진소수로 정확히 표현하기 힘들기 때문이다.
- 비록, 2진수가 유한소수라도, 가수를 저장할 수 있는 자리수가 한정되어 있으므로 저장되지 못하고 버려지는 값들이 있으면 오차가 발생한다.
- 2진수로 변환된 실수를 저장할때는 1.xxx X 2^n형태로 변환하는데 이 과정을 정규화라고 한다.

> 코드에서 float타입을 int타입으로 변환하는 함수가 존재하는데 아래와 같다.
``` java
Float.floatToIntBits();
```