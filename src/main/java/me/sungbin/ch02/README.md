> 참고
[자바의 정석](http://www.yes24.com/Product/Search?domain=ALL&query=%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D&pid=123487&cosemkid=go16214999081121496&gclid=Cj0KCQjwmuiTBhDoARIsAPiv6L9xwP5-CSNKhbr9xyqRtRORbKj8Eo29uQrx6hkOyS5ruqrFnfFy_h8aAplzEALw_wcB)
https://const17.github.io/5-swap/

## 변수란?
- 단 하나의 값을 저장할 수 있는 메모리 공간
- 새로운 값을 저장하면 기존의 값은 사라진다.

## 변수의 선언과 초기화

``` java
int age; // age라는 이름의 변수를 선언
```

- 위의 코드를 보면 여기서 'int'는 변수의 타입을 의미하며, 'age'는 변수의 이름을 말한다.
- 변수 타입은 변수에 저장될 값이 어떤 타입인지 지정하는 것을 말한다.
- C언어에는 정수형, 실수형, 문자형이 있다.
- 변수 이름은 변수에 이름을 붙이는것으로 메모리 공간에 이름을 붙여주는 것이다.
- 그래야 값도 저장이 가능하고 저장된 값을 읽어 올 수 있다.
- 그래서 같은 이름의 변수는 여러개가 될 수 없다.

> 즉, 메모리의 빈 공간에 변수타입에 알맞은 크기의 저장공간이 확보되고,
이 저장 공간은 변수이름을 통해 사용이 가능하다.

- 변수를 선언한 이후에 변수를 사용이 가능하나, 그 전에 반드시 변수를 초기화해야 한다.
- 메모리는 여러 프로그램이 공유하는 자원이므로, 전에 다른 프로그램에 의해 저장된
  알수 없는 쓰레기 값이 남아 있을 수 있기 때문에 초기화 작업을 거쳐야 한다.
- 초기화 작업은 아래와 같다.

``` java
int age = 25; // 변수 age를 선언하고 25로 초기화 한다.
```

> 위의 코드에 '='은 수학에서는 동등 연산자이지만, 프로그래밍에서는 대입연산자로 쓰인다.

> 변수의 종류에는 클래스 변수, 인스턴스 변수, 지역변수가 존재하는데
여기서 지역변수는 반드시 초기화를 해줘야 한다.

- 변수는 사용되기 전에 변수의 타입을 확인하고 적절한 값으로 초기화 작업을 하는것이 중요하다.

> 변수의 초기화란, 변수를 사용하기 전에 처음으로 값을 저장하는 것

- 변수에 저장된 값을 사용하려면, 그저 변수의 이름만 적어주면 된다.
- 변수의 값을 저장하는 '대입 연산자 (=)'는 우변의 모든 계산이 끝난 후에 제일 마지막에 수행한다.

### 두 변수의 값 교환하기
- 두 변수의 값을 교환하려면 어떻게 해야할까?
- 일반적으로 x라는 변수의 값을 y에 저장하고 y의 값을 x에 저장하면 될것 같지만
  원하는 결과를 얻지 못할 것이다.
- x라는 변수의 값을 y에 저장하면 b의 저장된 값이 변경되기 때문이다.
- 해결책은 아래의 그림처럼 임시 변수를 두는 것이다.

![](https://velog.velcdn.com/images/roberts/post/383987f6-59af-4599-b9b9-c6207c062b53/image.jpeg)

- 위의 그림처럼 temp라는 임시 변수에 값을 넣어두고 y의 값을 x에 temp의 값을 y에 저장해두면 된다.

> 참고
코딩을 하다보면 연산자를 많이 보게 될것이다.
그 중에 '+' 연산자는 두 값을 더하기도 하지만 문자열과 숫자를 하나로 결합하는 역할도 지닌다.

## 변수의 명명 규칙 (Naming Convention)
- 현업에서 일을 하다보면 변수의 이름을 짓는것에 시간을 꽤 투자한다.
- 일단 변수의 이름을 지을때 함부로 a,b,c.. 의미없는 이름을 쓰는것은 좋지 않은 습관이다.
- 또한 지켜야할 규칙이 있는데 바로 아래와 같다.

> 1. 대소문자가 구분되며 길이에 제한이 없다. (의미를 이해할수 있는 길이 정도)
     - True와 true는 서로 다른 것으로 간주된다.
2. 예약어를 사용하면 안 된다.
   - true는 예약어라 사용할 수 없지만, True는 가능하다.
3. 숫자로 시작해서는 안 된다.
   - top10은 허용하지만, 7up은 허용되지 않는다.
4. 특수문자는 '_'와 '$'만을 허용한다.
   - $harp는 허용되지만, S#harp은 허용되지 않는다.

> 예약어란 키워드 또는 리져브드 워드 (reserved word)라고 하는데,
클래스나 변수, 메서드 이름으로 사용할 수 없다.

![](https://velog.velcdn.com/images/roberts/post/0edf0294-3fec-4a6d-b26a-23694dd0febb/image.png)

> goto와 const는 실제로 사용되지 않으며, JDK1.4부터 assert라는 키워드가 추가되었으며
enum은 JDK1.5부터 새로 추가되었다.

## 자바 코드 규칙 (Java Code Convention)
- 필수적인것이 아니지만 자바 개발자들에게 권장하는 규칙들이 있다.

> 1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
     - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. (java Bean rule)
   - lastIndexOf, StringBuffer
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 '_'로 구분한다.
   - PI, MAX_NUMBER

> 참고
자바에서는 모든 이름에 유니코드에 포함된 문자를 사용할 수 있지만, 적어도 클래스 이름은 ASCII코드
(영문자)로 하는것이 좋다. 왜냐하면, 유니코드를 인식하지 못하는 운영체제도 있기 때문이다.

- 또한, 변수의 선언문에 주석으로 변수의 대한 정보를 간략히 적는것도 좋은 생각이다.

## 값의 분류
- 값의 종류는 크게 '문자와 숫자'로 나눌 수 있으며, 숫자는 다시 '정수와 실수'로 나눌 수 있다.

![](https://velog.velcdn.com/images/roberts/post/a5fc0d62-3403-4372-affb-1dd03e86a930/image.png)

- 자료형이란 겂의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이다.
- 변수의 타입은 저장할 값의 타입에 의해 결정이 된다.

## 기본형과 참조형
- 기본형 변수는 실제 값을 저장하는 반면, 참조형 변수는 어떤 값이 저장되어 있는 주소를
  값으로 갖는다.
- 자바는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은
  모두 기본형 변수이다.

> 참조
- 기본형 (primitive type)
    - 논리형(boolean), 문자형 (char), 정수형 (byte, short, int, long),
      실수형 (float, double) 계산을 위한 실제 값을 저장한다.
- 참조형 (reference type) (객체 생성하는 것을 생각하면 된다.)
    - 객체의 주소(메모리 주소)를 저장한다. 8개의 기본형을 제외한 나머지 타입 (4byte or 8byte).
      ex) String, System...

> 클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다.

- 참조 변수는 null 또는 객체의 주소를 값으로 갖는다.
- 참조변수의 초기화는 아래와 같다.

``` java
Date today = new Date(); // Date 객체를 생성해서, 그 주소를 today에 저장.
```

> 참고
참조형 변수는 null 또는 객체의 주소 (4byte)를 값으로 갖는다.
null은 어떤 객체의 주소도 저장되어 있지 않음을 뜻한다.
JVM이 32bit가 아니라 64bit라면 참조형 변수의 크기는 8byte가 된다.

> 자료형과 타입의 차이가 무엇인가?
굳이 차이는 없지만 엄밀히 이야기를 하면 다음과 같다.
기본형의 종류를 이야기할때는 자료형이라고 부르며, 참조형을 이야기 할때는 타입이라고 부른다.
즉, 타입이 자료형을 포함하는 보다 넓은 의미의 용어이므로 **굳이 구분하지 않아도 된다.**

## 기본형
- 기본형에는 모두 8개의 타입이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.
- 논리형
    * boolean
    * true와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용된다.
    * boolean은 다른 기본형과의 연산이 불가능하다.
- 문자형
    * char
    * 문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다.
    * 여러개의 문자를 저장하고 싶을 때는 String이라는 참조형 타입을 써야한다.
    * 문자를 내부적으로 정수 (유니코드)로 저장하기 때문에 정수형과 별반 다르지 않으며
      정수형 또는 실수형과 연산도 가능하다.
- 정수형
    * byte, short, int, long
    * 정수를 저장하는데 사용되며, 주로 int가 사용.
    * byte는 이진 데이터를 다룰 때 사용되며, short는 C언어와의 호환을 위해 추가
    * short 자료형은 잘 사용하지 않는다.
    * 정수형은 일반적으로 int를 사용한다. 왜냐하면, int는 CPU가 가장 효율적으로 처리할 수 있는
      타입이기 때문이다. 효율적인 메모리를 절약하려면 byte나 short를 선택하자.
- 실수형
    * float, double
    * 실수를 저장하는데 사용되며, 주로 double이 사용된다.

![](https://velog.velcdn.com/images/roberts/post/311b0db3-800f-4c74-97eb-137dbe418618/image.jpeg)

- boolean은 true와 flase 2가지 값만 표현할 수 있으면 되므로, 가장 작은 크기인 1byte.
- char은 자바에서 유니코드 (2byte 문자체계)를 사용하므로 2byte.
- byte는 크기가 1byte라서 byte.
- int (4byte)를 기준으로 짧아서 short (2byte), 길어서 long (8byte)
- float는 실수 값을 부동소수점 방식으로 저장하기 때문에 float.
- double은 float보다 2배의 크기 (8byte)를 갖기 때문에 double.

> 참조
n bit의 개수 : 2^n
n bit 중 부호없는 정수의 범위: 0 ~ 2^n -1
n bit 중 부호있는 정수의 범위: -2^(n-1) ~ 2^(n-1) - 1

![](https://velog.velcdn.com/images/roberts/post/365990f3-66c5-4c29-813f-77dd95e13b75/image.png)

- 위의 표를 달달 외울 필요는 없고 정수형 (byte, short, int, long)의 경우
  -2^(n-1) ~ 2^(n-1) - 1 이라는 정도만 기억하자.
- 실수형은 정수형과 달리 같은 크기라도 훨씬 큰 값을 표형할 수 있으나 오차가 발생할 수 있다는
  단점이 있다.
- 그래서 정말도가 중요한데, 정밀도가 높을수록 발생할 수 있는 오차의 범위가 줄어든다.
- float의 정밀도는 7자리인데, 이것은 10진수로 7자리의 수를 오차없이 저장할 수 있다는 뜻이다.

![](https://velog.velcdn.com/images/roberts/post/5c1830d1-c6e1-41ec-bc1e-ba91883b2098/image.png)

- 실수형에서는 저장 가능한 값의 범위뿐만 아니라 정밀도도 타입 선택의 중요한 기준이 된다.

## 상수 (constant)
- 상수는 변수와 같이 값을 저장할 수 있는 공간이지만 변수와 달리 다른 값으로 변경이 불가능하다.
- 상수는 한번만 값을 저장 가능한 변수
- 선언 방법은 변수와 같으며 단지, final 키워드만 붙여주면 된다.

``` java
final int MAX_SPEED = 10; // 상수 MAX_SPEED를 선언 및 초기화
```

- 상수는 반드시 선언과 동시에 초기화 해야하며, 그 후, 상수의 값을 변경하는것은 허용하지 않는다.
- 상수의 이름은 모두 대문자 (Named Convention)로 하는 것이 관례이며
  여러 단어로 이루어져 있으면 '_'로 구분한다.

> JDK1.6부터 상수를 선언과 동시에 초기화하지 않아도 되며, 사용하기 전에 초기화하면 되지만,
왠만하면 선언과 동시에 초기화 하는 습관이 중요하다.

## 리터럴 (literal)
- 리터럴은 우리가 기존에 알고 있던 '상수'의 다른 이름이다.
- 그 자체로 값을 의미하는것을 말한다.
- 프로그램에서 사용하는 모든 숫자, 값, 논리 값 ex) 10, 3.14, 'A', true
- 상수풀에 저장될때 정수는 int, 실수는 double로 저장

``` java
final int MAX_VALUE = 100; // 상수는 MAX_VALUE이고, 리터럴은 100이다.
```

## 상수가 필요한 이유
- 나도 처음에는 왜 상수가 필요한가 생각이 들었다. 리터럴을 직접 쓰면 되는데
  굳이 상수가 왜 필요할까 많은 생각이 들었다.
- 상수를 쓰는 이유는 복잡한 로직에서 리터럴에 '의미 있는 이름'을 붙여서
  코드의 이해와 수정을 쉽게 만들수 있다.

## 리터럴의 타입과 접미사
- 변수의 타입이 존재하는 것처럼 리터럴에도 타입이 존재한다.

![](https://velog.velcdn.com/images/roberts/post/10de0ed8-2eb8-42dc-b54c-3d7fb66ebce8/image.png)

- 리터럴에 붙이는 접미사는 대소문자 구분이 없다.
- 정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 접미사를 붙여서 타입을 구분한다.
- long 타입의 리터럴 접미사는 'l' 또는 'L'을 붙이고 접미사가 없으면 int타입 리터럴로 간주한다.
- byte와 short 타입 리터럴의 접미사는 따로 존재하지 않으며 int 타입 리터럴을 대신 사용한다.
- 또한 10진수 이외에도 2,8,16진수로 표현된 리터럴을 변수에 저장할 수 있으며
  16진수에는 '0x' 또는 '0X'를 사용하며 8진수에는 0을 붙인다.

> 2진수에는 JDK1.7부터 0b를 붙여서 사용한다.

- JDK1.7부터 정수형 리터럴의 중간에 구분자 '_'를 넣을 수 있게 되어 큰 숫자의 가독성이 쉬워졌다.
- 실수형에서 float 타입은 리터럴 접미사에 'f' 또는 'F'를 붙이고,
  double 타입의 리터럴은 'd' 또는 'D'를 붙이지만, 일반적으로 생략이 가능하다.
- 리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e, 그리고 접미사 f,F,d,DFMF 포함하고 있으면
  실수형 리터럴로 간주한다.

|자료형|실수형 리터럴|다른 형태의 동등한 표현|
|------|---|---|
|double|10.|10.0|
|double|.10|0.10|
|float|10f|10.0f|
|float|3.14e3f|3140.0f|
|double|1e1|10.0|
|double|1e-3|0.001|

- 잘 사용하지는 않지만 기호 p를 통해 2의 제곱을 표현하기도 한다.

## 타입의 불일치
- 리터럴의 타입과 변수의 타입이 일치하는게 매우 일반적이지만,
  타입이 달라도 저장범위가 넓은 타입의 값을 저장하는 것은 허용된다.

``` java
int i = 'A' // 문자 'A'의 유니코드인 65가 변수 i에 저장
long l = 123 // int보다 long타입이 더 범위가 넓다.
double d = 3.14f // float보다 double타입이 더 범위가 넓다.
```

- 그러나, 리터럴의 값이 변수의 타입의 범위를 넘어서면 에러가 발생한다.

> 참고
float은 접미사나 정밀도등 여러가지 신경쓸께 많으니, double을 그냥 사용하자.

## 문자 리터럴과 문자열 리터럴
- 작은따옴표로 문자 하나를 감싼 것을 '문자 리터럴', 두 문자 아싱은 큰 따옴표로 감싸야하며
  '문자열 리터럴이라고 한다.'
- char 타입의 변수는 단 하나의 문자만 저장이 가능하며, 여러 문자 (문자열)를 저장하기 위해서는
  String 타입을 사용해야한다.
- 문자열 리터럴에 "" 빈 문자열을 허용하지만, 문자 리터럴은 반드시 ''안에 하나의 문자가 있어야 한다.
- 원래 String은 클래스이므로, 아래와 같이 객체를 생성하는 new 연산자를 사용해야하지만,
  특별히 new 연산자를 사용안해도 된다.

``` java
String name = new String("JAVA");
String name = "JAVA"
```

- 덧셈 연산자를 사용하여 문자열을 결합할 수 있다.
- 덧셈 연산자는 피연산자가 모두 숫자일때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면
  나머지 한쪽을 먼저 String으로 형변환 후, 두 String을 결합한다.

> 문자열 + any type -> 문자열 + 문자열 -> 문자열
any type + 문자열 -> 문자열 + 문자열 -> 문자열

## 형식화된 출력 - printf()
- 화면에 출력할때 우리는 지금까지 System.out.println()을 써왔지만,
  값을 그대로 출력하기 때문에 값을 특정 포맷으로 출력하고 싶을때는 매우 불현하다.
- 이 점을 해결할 함수가 System.out.printf()함수 이다.
- printf() 함수는 지시자를 통해 어떻게 출력할 것인지를 지정해주는 역할을 한다.
- 출력을 2개를 하고 싶으면, 지시자를 2개를 지정해줘야한다.
- println과 또 다른 차이는 printf는 자동으로 개행을 해주지 않아서 %n이라는 지시자를 넣어줘야한다.

|지시자|설명|
|------|---|
|%b|불리언 (boolean) 형식으로 출력|
|%d|10진 정수의 형식으로 출력|
|%o|8진 정수의 형식으로 출력|
|%x, %X|16진 정수의 형식으로 출력|
|%f|부동 소수점의 형식으로 출력|
|%e, %E|지수 표현식의 형식으로 출력|
|%c|문자로 출력|
|%s|문자열로 출력|

> 참조
Integer.toBinaryString(int i) : 정수를 2진 문자열로 변환
%g: 실수형 값을 간략히 표현할때 사용

## 화면에서 입력받기 - Scanner
- Scanner 클래스를 이용하여 사용자가 직접 입력을 할 수도 있다.
- 방법
    * import java.util.*; // Scanner 클래스를 사용하기 위해 추가
    * Scanner scanner = new Scanner(System.in); // Scanner 클래스의 객체 생성
    * String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
    * int num = Integer.parseInt(input); // 입력받은 내용을 input 타입의 값으로 변환

## 10진법과 2진법
- 우리는 일상생활에서 흔히 10진법을 사용한다. 아마 손가락이 10개여서
  우리 인간은 10진법을 받아들였던것 같다.
- 이처럼, 애니악이라는 컴퓨터에도 10진법을 적용시켜보았지만 전압이
  매우 불안정했다. 그래서 컴퓨터 같은 기계에는 전기가 흐르면 1, 전기가
  흐릐지 않으면 0인 2진법을 도입시키게 되었다.
- 그래서 2진법을 제대로 알지 못하면, 컴퓨터의 동작원리, 데이터 처리방식을
  온전히 이해할 수 없게 된다.
- 변수의 저장원리도 마찬가지다. 지금까지는 10진수가 저장되는 것처럼 설명을
  했지만, 사실은 10진수의 정수가 대입이되면, 10진수의 정수가 2진수로 변환되어 저장이 된다.
- 2진법은 0과 1로만 데이터를 표현하기 때문에, 10진수보다 많은 자릿수가
  필요하다.
- 2진수가 자릿수가 많이 필요하긴 하지만, 10진수를 온전히 표현 못하는건 아니다.
  덧셈이나 뺄쎔같은 연산도 10진수와 동일한 로직이다.

## 비트와 바이트
- 한 자리의 2진수를 비트라고 하며, 1비트는 컴퓨터가 값을 저장할 수 있는
  최소단위이다.
- 8비트를 1바이트라고 하며, 데이터의 기본단위로 사용한다.
- 워드는 CPU가 한번에 처리할 수 있는 데이터의 크기를 말하며,
  워드의 크기는 4바이트이긴 하지만 CPU성능에 따라 달라진다.
  ex). 32비트 CPU에서는 1워드는 4바이트이고 64비트 CPU에서는 1워드는 8바이트이다.

![](https://velog.velcdn.com/images/roberts/post/429b9d78-bfa0-4acf-9abe-82d55d9973e1/image.png)

![](https://velog.velcdn.com/images/roberts/post/a4fa59cd-6a4a-4e93-ba6d-9c632b0a20b4/image.png)

> n비트로 표현할 수 있는 10진수
- 값의 개수 : 2^n
- 값의 범위 : 0 ~ (2^n)-1

## 8진법과 16진법
- 8진수는 2진수 3자리를, 16진수는 2진수 4자리를 각각 한자리로 표현할 수 있기 때문에 자리수가 짧아져서 알아보기 쉽고 서로간의 변환방법 또한 매우 간단하다.

![](https://velog.velcdn.com/images/roberts/post/dfdfb68f-677f-4a54-a40c-c3b6bd0ecfb2/image.png)


### 2진수를 8진수, 16진수로 변환

![](https://velog.velcdn.com/images/roberts/post/3aedce32-9d5f-4e6b-8aa0-620e6af61270/image.png)

## 정수의 진법 변환
- 10진수를 n진수로 변환
    * 10진수를 다른 진수로 변환할려면 해당 진수로 나누고
      나머지 값을 옆에 적는 것을 더 이상 나눌 수 없을 때까지
      반복한 다음 마지막 몫과 나머지를 아래부터 위로 순서대로 적으면 된다.
- n진수를 10진수로 변환
    * 어떤 진법의 수라도 변환하는 방법은 똑같다. 각 자리의 수에 해당
      단위의 값을 곱해서 더하면 된다.

## 실수의 진법 변환
- 10진 소수점수를 2진 소수점수로 변환하는 방법
    * 10진 소수점수를 2진 소수점수로 변환하는 방법은 10진 소수점수에
      2를 계속 곱하는 것이다.

  > ex) 0.625의 십진수를 2진수로 변화할려면?
    1) 10진 소수에 2를 곱한다.
    2) 위의 결과에서 소수부만 가져다가 2를 곱한다.
    3) 1,2의 과정을 소수부가 0이 될때 까지 반복한다.
    4) 위의 결과에서 정수부만을 위에서 아래로 순서대로 적고 '0.'을 앞에 붙인다.

- 2진 소수점수를 10진 소수점수로 변환하는 방법
    * 소수점수를 가져다가 (2^-n)식으로 곱해주면 된다.

## 음수의 2진 표현 - 2의 보수법

![](https://velog.velcdn.com/images/roberts/post/ec9b65ea-8a3e-40c4-9fc2-87eb0afa456d/image.png)

- 우리가 앞에서 살펴봤듯이 n비트의 2진수로 표현할 수 있는 부호없는 정수의 값의 개수는 2^n이다.
- 그러면 양수와 음수를 둘다 표현할려면 어떻게 해야할까?
- 왼쪽의 첫번째 비트 (MSB)가 0이면 양수, 1이면 음수로 첫번째 비트만으로
  값의 부호를 알 수 있다.
- 하지만, 첫번째 비트만 바꿔주면 문제점이 발생한다. 양수의 2진수로 첫번째 비트를 1로만 바꿔준 음수를 더하면 논리상 0이되어야 하지만 그렇지가 않는다.
  또한, 0과 -0이 2개가 생긴다는 단점이 있다. 게다가 2진수가 증가할때 10진수는 감소한다는 단점이 존재한다.
- 하지만 2의 보수법을 이용하면 위의 문제점들이 해결이 가능하다. 다만, 첫번째 비트만 바꿔서 음수가 된다는 장점은 사라진다. 하지만 내 생각이지만, 수 많은 단점을 해결하고 장점을 포기한다는 것은 당연한 해결이라고 생각한다.

### 2의 보수법
- 어떤수의 'n의 보수'는 **더했을 때 n이 되는 수**를 말한다.
- 2의 보수도 마찬가지로 더해서 2가되는 두수의 관계를 말한다.
- 즉, 10진수 2는 2진수로 '10'을 의미하며, 자리올림이 발생하고 0이 되는 수를 2의 보수라고 볼수 있다.
- 그래서, 2의 보수 관계를 지닌 두 2진수를 더하면, (자리올림이 발생하고) 0이된다.
- 그래서 2의 보수를 어떻게 구해야 할까? 정답은 각 자리의 수가 1이면 0으로 0이면 1로 바꾼 수에서 1을 덧셈연산을 한다.
- 그러면 음수를 2진수로 바로 변환은 가능할까? 물론 가능하다.
    * 10진 음의 정수를 절대값을 2진수로 변환하고, 2의 보수를 구하면 된다.

> 음수의 2진 표현을 구하는 방법
1. 음수의 절대값을 2진수로 변환한다.
   : -5의 절대값인 5를 2진수로 변환한다. 10진수 5를 2진수로 변환하면 '0101'이 된다.
2. 위의 결과에서 1를 0으로 0을 1로 바꾼다. (1의 보수 구하기)
   : '0101'이 '1010'이 된다.
3. 위의 결과에서 1을 더한다. (2의 보수 구하기, 1의 보수 + 1)
   : '1010'에 1을 더하면 '1011'이 되고 이것이 -5의 2진표현이다.