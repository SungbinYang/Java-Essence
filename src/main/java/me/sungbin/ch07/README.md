> 참고
[자바의 정석](http://www.yes24.com/Product/Search?domain=ALL&query=%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D&pid=123487&cosemkid=go16214999081121496&gclid=Cj0KCQjwmuiTBhDoARIsAPiv6L9xwP5-CSNKhbr9xyqRtRORbKj8Eo29uQrx6hkOyS5ruqrFnfFy_h8aAplzEALw_wcB)
https://yadon079.github.io/2020/java/07-object-oriented-programming-ii-01
https://blog.daum.net/question0921/946

## 상속
### 상속의 정의와 장점
상속이라고 생각하면 '부모님이 자식한테 재산을 상속한다.'의 상속이 먼저 떠오를 것이다. 프로그래밍에서 상속도 이와 유사한 개념이다. 프로그래밍에서 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 이용하면 적은양의 코드로 새로운 클래스를 작성할 수도 있고 공통적인 코드를 쉽게 관리 할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다. 또한 코드의 재사용성이 높이지면서 중복이 제거되고 생산성과 유지보수성에 크게 기여한다.
상속을 구현하는 법은 클래스 이름 뒤에 extends라는 키워드를 붙여주고 상속할 클래스 이름을 적어주면 된다.

``` java
class Child extends Parent {
}
```

위의 코드는 상속을 표현한것인데 Parent 클래스와 Child 클래스는 서로 상속관계라 하면 Parent클래스를 부모 클래스라고 하며 Child 클래스를 자식 클래스라고 한다.

> 부모 클래스 = 조상 클래스 = 상위 클래스 = 기반 클래스
자식 클래스 = 자손 클래스 = 하위 클래스 = 파생된 클래스

참고로 구체적인 클래스를 설계할 때 상속을 많이 이용한다.  즉, 새로운 클래스를 정의할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능이 확장되는 클래스를 구현하는 할 때 상속을 이용한다. 그리고 상속을 할 때는 서로 이질적인 클래스간에는 상속을 하면 안된다.


![](https://velog.velcdn.com/images/roberts/post/504f07fb-d7a1-4717-a174-a59fce0ef463/image.png)


위의 2번째 그림은 클래스 상속관계를 화살표로 표시하였고 1번째 그림은 클래스 상속관계를 수학에서 집합과 같이 벤다이어그램으로 표현하였다. 이처럼 클래스 간의 상속관계를 그림으로 표현한 것을 상속계층도라고 한다. 나중에 코딩을 하다보면, 상속관계가 복잡할 때가 있는데 이렇게 그림으로 천천히 그려서 확인해보면 이해가 빠를 것이다.
1번째 그림을 살펴보면 자식 클래스가 부모 클래스를 포함하고 있는데, 그 이유는 부모클래스에 메서드나 속성을 추가하면 자식클래스가 그것을 상속 받기 때문에 부모의 속성이나 메서드를 가지고 있다.

``` java
class Parent {
	int age;
}

class Child extends Parent {

}
```

위의 코드를 보면 Parent클래스를 Child 클래스가 상속받고 있으므로 Parent 클래스의 age도 Child 클래스가 내포하고 있는것과 같다.

#### 상속을 사용하는 경우
- 상위 클래스는 하위 클래스보다 일반적인 개념과 기능을 가짐
- 하위 클래스는 상위 클래스보다 구체적인 개념과 기능을 가짐

> ⚠️ 주의
extends 뒤에는 단 하나의 class만 사용할 수 있다. 자바는 single inhertance만 지원한다.
C++이나 다른 객체지향언어를 배우신 분들은 헷길릴수 있다. C++에서는 다중상속을 지원하기 때문이다.

``` java
class Parent {
	int age;
}

class Child extends Parent {
	void play() {
    	System.out.println("play~");
    }
}
```

위의 코드를 보면 Child클래스에 play()라는 메서드를 추가했다. 하지만 Parent클래스는 전혀 영향을 받지 않는다. 여기서 알 수 있는 것처럼 상위 클래스가 변경되면 하위 클래스는 자동적으로 영향을 받게 되지만, 그 반대는 아무런 영향을 주지 않는다. 그리고 상속을 계속 할 수록 멤버 개수는 점점 증가한다.

> - 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 부모 클래스의 멤버 개수는 자식 클래스보다 항상 같거나 많다.

> 나중에 뒤에서 배우겠지만 접근제어자 (private, defaulr)가 붙은 멤버들은 상속은 되지만, 자식 클래스에서 접근이 불가능해서 마치 상속을 못 받은것처럼 보일 수 있다.

![](https://velog.velcdn.com/images/roberts/post/1561c289-69b8-4abb-8340-8da87356cfc2/image.jpeg)

``` java
class Animal {}
class Cat extends Animal {}
class Dog extends Animal {}
```

위의 그림과 코드를 보면 Cat 클래스와 Dog 클래스는 Animal이라는 상위 클래스를 상속 받고 있다. 즉, 고양이 클래스와 강아지 클래스는 동물이라는 상위클래스를 가졌다. 하지만, 같은 상위 클래스를 상속받는다 해서 Cat클래스와 Dog클래스가 무슨 관계가 있는 것이 아니다. 같은 상위 클래스를 상속받았다는 점만 같을 뿐이다. 이처럼 같은 내용의 코드를 상위 클래스에서 관리하면 코드의 중복이 줄어든다는 사실이다. 코드의 중복이 줄어들어서 유지보수 및 일관성을 유지시킬 수 있다. 만약 자신이 짜는 코드가 중복된 코드가 많다고 느껴지면 상속을 이용하는 것을 좀 고려를 해 볼 필요가 있다.

> 전체 프로그램을 구성하는 클래스들을 면밀히 설계분석하여, 클래스간의 상속관계를 적절히 맺어 주는 것이 객체지향 프로그래밍에서 가장 중요한 부분이다.

> 하위 클래스의 인스턴스를 생성하면, 상위 클래스의 멤버와 하위 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

### 클래스간의 관계 - 포함관계
우리는 상속을 통하여 클래스를 재사용하는 방법을 알아봤다. 하지만 클래스 재사용하는 방법은 '포함관계'를 통해 재사용 할 수 있다. 클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다. 아래의 코드를 보면 포함관계를 명확히 알 수 있을 것이다.

``` java
// 포함관계를 표현하지 않은 상태
class Circle {
	int x;
    int y;
    int r;
}
```

``` java
class Point {
	int x;
    int y;
}

// 포함관계를 사용한 상태
class Circle {
	Point p = new Point();
    int r;
}
```

이처럼 클래스 안에 멤버변수로 다른 클래스를 포함시키는 것은 매우 좋은 아이디어이다. 하나의 거대한 클래스를 만들어 가는것 보단, 여러개의 클래스로 나눠서 포함관계로 재사용하면 사용하는 입장에서 가시성이 좋을 것이다. 아래의 코드처럼 말이다.

``` java
class Car {
	Engine e = new Engine(); // 차는 엔진을 가지고 있다.
    Door[] d = new Door[4]; // 차는 문이 4개이다.
}
```

위 코드처럼 단위클래스별로 코드가 작게 나뉘어 작성되어 있기 때문에 코드를 관리하는데 수월할 것이다.

### 클래스간의 관계 결정하기
그러면 지금 많이 헷갈릴 것이다. "그래서? 언제 상속관계로 해주고 언제 포함관계로 해줘야해?"

``` java
class Circle {
	Point p = new Point();
    int r;
}
```

``` java
class Circle extends Point {
	int r;
}
```

위의 코드들 중에 어떤 걸로 해야할까? 정답은 바로 관계를 보는 것이다.

> 자식클래스는 부모클래스이다. (**IS-A 관계**) -> 상속
자식클래스는 부모클래스를 가지고 있다. (**HAS-A 관계**) -> 포함

그러면 바로 적용해보자. '원은 점이다.'가 맞을까? '원은 점을 가지고 있다'가 맞을까? 정답은 후자이다.
IS-A관계는 상속관계를 이용하면 되고. HAS-A관계는 포함관계를 이용하면 된다. 원과 점 클래스는 HAS-A관계가 맞으므로 포함관계를 이용하면 된다.

> 하지만 IS-A관계, HAS-A관계가 항상 맞지는 않다. 뭔가 논리적으로 명확하지 않은 경우가 있다.
일단 먼저 이 관계들을 적용해보고 논리적으로 더 맞는것을 선택해보자. 그러면 왠만하면 필터링이 될것이다.

#### toString()
코드를 작성하다보면 확인용도로 객체의 정보를 출력할 때가 있다.

``` java
Car c = new Car();

System.out.println(c); // System.out.println(c.toString());과 같다.
```

위처럼 코드를 실행하면 객체의 주소값이 출력이 될것이다. 하지만 우리가 원하는 것은 객체의 주소가 아니라 객체안에 멤버변수들의 정보이다. 이럴때 toString()을 재정의하는 것이다. 원래 toString()은 인스턴스의 정보를 문자열로 반환할 목적으로 정의된 것이다. 참조변수의 출력이나 덧셈연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치 후 처리한다.

### 단일 상속
다른 객체지향언어인 C++에서는 다중상속이 가능하다. 하지만, 자바에서는 단일 상속만 허용한다.
막상보면 다중상속이 여러 부모 클래스를 상속받아서 확장성에 뛰어나다고 복합적 기능을 만들 수 있다는 장점만 보일 것이다. 하지만, 클래스 간의 관계가 매우 복잡해지며, 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같을 경우 구별할 수 있는 방법이 없다는 단점을 가지고 있다.
단일 상속이 하나의 부모 클래스만을 가질 수 있기 때문에 다중상속에 비해 불편한 점도 있지만 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 점에서 다중상속보다 유리하다.

만일 다중상속을 정말 할 상황이라면 IS-A관계 혹은 HAS-A관계를 생각해서 하나는 상속받고 하나는 포함관계를 하면 다중상속과 같은 비슷한 효과를 볼 수 있다.

### Object 클래스 - 모든 클래스의 조상
Object클래스는 모든 클래스의 최상위에 있는 부모클래스이다. 쉽게 생각해서 클래스계 단군할아버지라고 생각하면 될것이다. 아래와 같이 Tv라는 클래스를 정의했다고 해보자.

``` java
class Tv {
}
```

여기서 Object클래스가 최상위 부모클래스라고 했으니 뒤에 extends 키워드 붙이고 뒤에 Object를 붙여줘야하는거 아닐까? 정답은 맞다. 컴파일 단계에서 자동으로 ```extends Object```를 붙여준다.
즉, 위의 코드가 아래의 코드처럼 바뀐다.

``` java
class Tv extends Object {
}
```

이렇게 함으로 Object클래스가 모든 클래스의 조상이 되도록 한다.
모든 상속계층도의 최상위에는 Object 클래스가 위치한다. 그래서 우리가 아까 toString()이나 equals(Object o)와 같은 메서드를 사용할 수 있던 것이다. 이 메서드들은 Object 클래스에 정의되어 있기 때문이다.

> 참고로, 이미 어떤 클래스로부터 상속받도록 extends되어 있는 클래스는 컴파일러가 따로 ```extends Object```를 붙여주지 않는다. 그 이유는 그 상속하려는 부모클래스가 Object를 상속받기 때문이다.

## 오버라이딩
### 오버라이딩이란?
**상위 클래스에서 상속받은 메서드를 재정의 하는 것을 오버라이딩이라고 한다.**
좀 더 풀어서 말하면 상위클래스에서 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름의 메서드로 재정의 하는 것이다.

``` java
class Point {
	int x;
    int y;
    
    String getLocation() {
    	return "x: " + x + ", y: " + y;
    }
}

class Point3D extends Point {
	int z;
    
    @Overriding
    String getLocation() {
    	return "x: " + x + ", y: " + y + ", z: " + z;
    }
}
```

위의 코드를 보면, Point 클래스에서 getLocation 메서드로 x, y좌표를 출력한다. 하지만 Point3D 클래스에서는 z좌표까지 출력을 해야한다. 이럴때 보통 우리는 새로운 메서드를 정의하지만 정말 좋지 못한 방법이다. 그러면 어떻게 하면 좋을까?
바로 Point 상위 클래스의 getLocation을 재정의하면 될것이다. 상위클래스와 같은 메서드 명으로 정의하고 위에다가 @Overriding이라는 애노테이션을 붙여주면 된다.

> IDE를 사용하면 @Overriding이라는 애노테이션은 저절로 붙여준다.

### 오버라이딩의 조건
오버라이딩은 메서드의 내용만을 새로 작성하는 것으로 메서드의 선언부는 상위클 래스와 완전히 일치해야한다. 이것말고 지켜야할 규칙이 있는데 아래의 내용을 살펴보자.

> 오버라이딩 조건
1. 상위클래스의 메서드 이름과 같아야 한다.
2. 매개변수가 같아야 한다.
3. 반환타입이 같아야 한다.

> 💡 참고
JDK1.5부터 공변 반환타입이 추가되어, 반환타입을 하위클래스의 타입으로 변경하는 것은 가능하도록 조건이 완화되었다.

설명이 길었는데 요약하자면, 선언부가 서로 일치해야 한다는 것이다.
단, 접근제어자와 예외는 제한된 조건하에서만 다르게 변경할 수 있다.

1. **접근 제어자는 상위 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.**
    * 예를 들어 상위 클래스에 접근제어자가 protected로 설정이 되어 있다면 하위클래스의 접근제어자는 protected나 public으로 설정해줘야한다.
    * 보통은 같은 범위의 접근제어자를 사용하지만, 가끔 특이한 경우에 다른 접근제어자를 사용해야 하는 경우가 있는데, 이럴때 이 원칙을 생각하면 될것이다.
    * 접근 제어자의 접근 범위를 넓은 범위에서 좁은 범위 순으로 표현하면 다음과 같다. (public > protected > (default) > private)

2. **상위 클래스의 메서드보다 많은 수의 예외를 선언 할 수 없다.**
   아래의 코드를 살펴보자.

``` java
class Parent {
	void method() throws IOException, SQLExcetion {
    	// ...
    }
}

class Child extends Parent {
    @Overriding
    void method() throws IOExcetion {
    	// ...
    }
}
```

* 위의 코드를 살펴보면 올바르게 오버라이딩이 구현된 코드이다. 상위 클래스에서 method()라는 메서드에는 예외 클래스 개수가 2개이고 하위 클래스는 예외 클래스 개수가 1개임으로 적절히 구현된 코드이다.
* 하지만 주의해야 할 점은 단순히 선언된 예외의 개수의 문제가 아니다.
  아래의 코드를 살펴보자.

``` java
class Parent {
	void method() throws IOException, SQLExcetion {
    	// ...
    }
}

class Child extends Parent {
    @Overriding
    void method() throws Excetion {
    	// ...
    }
}
```

* 위의 코드는 분명 상위 클래스의 예외 클래스 개수보다 하위 클래스의 예외 클래스의 개수가 적다. 하지만 위 코드는 오버라이딩의 잘못 구현된 예이다. 이유가 무엇일까?
* 하위 클래스의 예외 클래스는 모든 예외의 최상위 클래스인 Exception 클래스이므로 가장 많은 개수의 예외를 던질수 있어서 잘못된 예이다.
* 이처럼 예외의 상속구조도 오버라이딩을 구현할 때 잘 생각해야하는 부분이다.

> 💻 정리
상위 클래스의 메서드를 하위 클래스에서 오버라이딩 할 때,
1. 접근 제어자를 상위 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
2. 예외는 상위 클래스의 메서드보다 많이 선언할 수 없다.
3. 인스턴스 메서드를 static메서드 또는 그 반대로 변경이 불가능하다.

> 🙋🏻 Q. 상위 클래스에 정의돤 static 메서드를 하위 클래스에서 똑같은 이름의 static메서드로 재정의 가능한가?
💁🏻 A. 가능하다. 하지만, 이것은 각 클래스에 별개의 static 메서드를 정의한 것일 뿐 오버라이딩이 아니다. 각 메서드는 클래스이름으로 구별하며, 호출할 때는 '참조변수.메서드()' 대신에, '클래스이름.메서드이름()'으로 하는 것이 정석이다. static 멤버들은 자신들이 정의된 클래스에 묶여 있으며, 상속이 안된다고 생각하면 좋을 것이다.

### 오버로딩 vs 오버라이딩
오버로딩과 오버라이딩이 용어가 헷갈려서 혼돈이 되지만, 명확히 다른 수행을 하는 것이다. 한번 살펴보자.

> 오버로딩: 기존에 없는 새로운 매서드를 정의하는 것
오버라이딩: 상속받은 메서드의 내용을 변경하는 것

``` java
class Parent {
	void method() {}
}

class Child extends Parent {
	void method() {} // 오버라이딩
    void method(int i) {} // 오버로딩
    
    void childMethod() {} // 자식 클래스의 메서드
    void childMethod(int i) {} // 오버로딩
}
```

### super
super는 하위 클래스에 상위 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다. 멤버변수와 지역변수를 구분할때 this를 사용했듯이 상속받은 멤버와 자신의 멤버를 구분할때 super를 붙을때 구별한다.
상위 클래스로부터 상속받은 멤버도 하위클래스의 멤버임으로 this로 접근이 가능하지만, 중복정의가 되었을 경우 super와 this로 구분해서 사용하는 것이 좋다. 그리고 모든 인스턴스 메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장하는데 이것이 참저변수인 this와 super다. 또한, this와 마찬가지로 super역시 static메서드에서는 사용할 수 없고 인스턴스 메서드에 사용이 가능하다.

변수만이 아니라 메서드 역시 super를 써서 부모 클래스의 메서드를 호출 할 수 있다. 특히, 상위 클래스의 메서드를 하위 클래스에서 오버라이딩한 경우에 super를 사용한다.

``` java
class Point {
    int x, y;

    String getLocation() {
        return "x : " + x + ", y: " + y;
    }
}

class Point3D extends Point {
    int z;

    @Override
    String getLocation() {
        return super.getLocation() + ", z: " + z;
    }
}
```

### super() - 상위 클래스의 생성자
this()와 마찬가지로 super()도 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는데 사용되며, super()는 상위 클래스의 생성자를 호출하는데 사용된다.
하위 클래스의 인스턴슨 생성시, 상위 클래스의 멤버가 포함된 인스턴스가 생성이 된다. 그래서 하위클래스의 인스턴스가 상위클래스의 멤버들을 사용할 수 있는것이다. 이때, 상위 클래스의 멤버들이 초기화되어야 함으로 상위클래스의 생성자가 호출되어야 함으로, 하위 클래스에서 상위 클래스의 생성자가 호출되어야 한다. 그래서 this()와 비슷하게 하위 클래스의 생성자의 첫 줄에 상위 클래스의 생성자를 호출해야 한다. 왜냐하면, 하위 클래스의 멤버가 상위 클래스의 멤버를 사용할 수 있기 때문이다.
그러면 우리가 하나 생각해볼 것이 있다. Object는 모든 클래스의 최상위 클래스인데 우리가 일반적으로 클래스를 정의할 때 super()를 붙여주지 않았다. 그 이유는 ```extends Object```와 비슷한 이유다. 컴파일러가 자동으로 생성자에 ```super()```를 추가해준다.

> Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자 this() 또는 super()를 호출해야 한다. 그렇지 않으면, 컴파일러가 자동으로 super()를 생성자의 첫줄에 삽입한다.